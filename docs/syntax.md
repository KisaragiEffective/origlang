<!-- SPDX-License-Identifier: CC-BY-4.0 -->
# 文法

この言語の文法は至って単純です。

## 空白

トークンの間の空白文字 (U+0020) はレキサーにより読み飛ばされます。

文字列リテラル及びキーワードの後に式が続く場合、空白を除去すると意味が変わります。

## 改行

改行コードはLF (`\n`) または CRLF (`\r\n`) をサポートします。どちらもトークン化の際は単なる改行として取り扱われます。

現状余計な改行を入れることはできません。これは実装の都合によります。将来的には、この制限事項は解除される予定です。

ただし、`block`式の`block`キーワードの直後だけは例外です。

## コメント

1行コメントは行頭から`//`で始めることにより書くことができます。改行までがコメントとして扱われ、コンパイル時には無視されます。

言い換えると、コメントは特別な意味を持たず、削除してもプログラムの動作が変わることはありません。

以下に例を示します。

```
// this is comment
```

1行コメントは行の途中から書くことはできません。これは実装の都合によるものです。将来的にはこの制限は削除される予定です。

以下のコードスニペットはコンパイルに失敗します。

```
print "Hello World!" // Hello, World!
```

## 評価戦略

この言語は正格評価を採用しています。

この言語の評価順序は上の行から下の行へ、左の式から右の式へ評価されます。

## 識別子

識別子として使える文字は、ASCIIの範囲内にある大文字、小文字、及び数字です。

識別子は、それらの文字を1回以上繰り返した文字列です。ただし、識別子の最初の文字が数字であってはなりません。

### 識別子のスコープ

宣言された識別子はそれ以降の行、及びその内側のスコープで使うことができます。この言語の「スコープ」は全てレキシカルスコープであり、トークン列から静的に決定することができます。

前方参照は許されません。次のコードはコンパイルに失敗します。

```
print a
var a = 1
```

## 式

式となるものは、中置演算子の呼び出し、優先式、`block`式、`if`式、リテラル、変数があります。

### 中置演算子の呼び出し

中置演算子は`1 + 2`のように、第一オペランド、中置演算子、第二オペランドの順で記述して呼び出します。

各中置演算子の性質は次の表に示したとおりです。

| 演算子   | 優先順位 |結合性|呼び方|
|:------|:-----|:----|:----|
| `*`   | 1    |左   |乗算  |
| `/`   | 1    |左   |除算  |
| `+`   | 2    |左   |加算  |
| `-`   | 2    |左   |減算  |
| `<<`  | 3    |左   |     |
| `>>`  | 3    |左   |     |
| `<=`  | 4    |左   |以下  |
| `<`   | 4    |左   |未満  |
| `>=`  | 4    |左   |以上  |
| `>`   | 4    |左   |大きい|
| `<=>` | 4    |左   |宇宙船|
| `==`  | 5    |左   |等価  |
| `!=`  | 5    |左   |非等価 |

各中置演算子のオペランドは同じ型でなければなりません。これに従わなかった場合、コンパイル時にエラーが発生します。

各中置演算子が返す型はそれぞれ次のとおりです。
* `*` - オペランドの型
* `/` - オペランドの型
* `+` - オペランドの型
* `-` - オペランドの型
* `<=` - 常に真偽値型
* `<` - 常に真偽値型
* `>=` - 常に真偽値型
* `>` - 常に真偽値型
* `<=>` - 整数型[^1]
* `==` - 常に真偽値型
* `!=` - 常に真偽値型

[^1]: 将来的には、これは特殊な列挙型に変わる可能性があります。

### 優先式

丸括弧で式を囲うと、その部分は式の優先順位に関わらず優先して評価されます。

### `block`式
`block`...`end`で囲った部分は`block`式と呼ばれます。

この式の内部はレキシカルスコープを形成します。

最後に評価された式の結果がその`block`式の評価した結果として返されます。

### `if`式
`if`...`then`...`else`...は`if`式と呼ばれます。

`if`の後には条件式を、`then`の後には条件式が`true`に評価されたときに評価される式 (`then`節) を、`else`の後には条件式が`false`に評価されたときに評価される式 (`else`節) を与えます。

`then`節と`else`節は条件によってどちらかが評価され、両方が評価されることはありません。

`then`節と`else`節はそれぞれレキシカルスコープを形成します。

複数行の式を書きたいときは前述した`block`式を使います。例えば、リスト1はC言語のリスト2とほぼ同様です。

リスト1:
```
var a = if true then block
    print "Hello!"
    1
end else block
    print "oof"
    2
end
```

リスト2:
```c
int a;
if (true) {
    puts("Hello!");
    a = 1;
} else {
    puts("oof");
    a = 2;
}
```

### リテラル

文字通りの値に評価される式です。

#### 数値リテラル

10進数の値を記述すると数値リテラルになります。`i8`・`i16`・`i32`・`i64`のいずれかを後ろにつけると整数型のビット幅を明示することができます。

その型にとってオーバーフローするような値を記述するとコンパイルエラーになります (例: `65535i8`)。

#### 文字列リテラル

半角ダブルクォーテーション (`"`) で文字列リテラルを開始し、半角ダブルクォーテーションで文字列リテラルを終了します。エスケープシーケンスは現状使うことができません。

#### 真偽値リテラル

`true`と`false`は、それぞれその値に評価される真偽値型のリテラルです。

#### タプルリテラル

式が期待される文脈で丸括弧の中に式を2つ以上コンマ区切りで書くと、タプル型として推論されるリテラルの式になります。

リスト3: このリストで`x`は`(Int16, Int32)`になります。

```
var x = (1i16, 2i32)
```

#### ユニットリテラル

`()`と書くと、ユニット型を持つ式になります。

### 変数

変数は箱です。`var ident = expr`という構文で宣言することができます。

```
var a = 42i32
var b = ("", 0i64)
```

上のコードは型推論が行われ、次のコードと全く同じです。
```
var a: Int32 = 42i32
var b: (String, Int64) = ("", 0i64)
```

変数の宣言時に型が固定されます。型注釈と異なる型を持つと推論される値を代入するとコンパイルエラーになります。

変数は同じ名前で再宣言できます。再宣言した後、再宣言する前の変数は参照できなくなります。

変数の識別子を`_`にすると、右辺値が評価された後捨てられます。

```
var _ = block
  print 1
  ()
end
```

`_`は有効な右辺値として使えません。次のコードはパースに失敗します。

```
var _ = _
```

タプルは分解することができます。例:

```
var (a, b) = (1, 2)
// => 1
print a
// => 2
print b
```

```
var (c, _) = (3, 4)
// => 3
print c
```

```
var (_, d) = (5, 6)
// => 6
print d
```

```
var (e, f, g) = (7, 8, 9)
// => 7
print e
// => 8
print f
// => 9
print g
```

```
var (i, (j, k)) = (10, (11, 12))
// => 10
print i
// => 11
print j
// => 12
print k
```

```
var l = (13, 14, 15)
var (m, (n, o)) = l
// => 13
print m
// => 14
print n
// => 15
print o
```

## 文

式があれば文もあります。

### `block`文

`block`...`end`でブロックを形成します。

このコンストラクトによって形成されるブロックはレキシカルスコープを形成します。

### `print`文

`print 式`という構文で標準出力へ式を文字列化した結果を改行付きで出力します。

### `var`文

`var ident = expr`という構文で変数を宣言します。

### `exit`文

`exit`で現在のプログラムの実行を終了します。

### `type`文

`type`で型エイリアスを定義することが出来ます。

```
type VeryLargeTuple = (String, Int32, Int64, Int16, Int8, Unit, Boolean)
```

`type`で定義した型エイリアスはエイリアスする前の型と相互に交換可能です。

```
type Hello = Int32
var x: Hello = 0i32
```

## 型システム

現状型付けラムダ計算に相当する型システムを持っています。多相はありません。サブタイピングもありません。

* `Int8` - 8ビット符号付き整数
* `Int16` - 16ビット符号付き整数
* `Int32` - 32ビット符号付き整数
* `Int64` - 64ビット符号付き整数
* `Bool` - 真偽値型
* `String` - 文字列型
* `Unit` - ユニット型
* `(T1, T2, ...)` - タプル型
